# <center> rustå­¦ä¹ 
# ä¸‹è½½å’Œå®‰è£…
```shell
# rustå®˜ç½‘ä¸‹è½½
# æ–°å¢ç¯å¢ƒå˜é‡
CARGO_HOME   D:\develop_tool\rust\.cargobin
RUSTUP_HOME  D:\develop_tool\rust\.rustup
# æ‰§è¡Œä¸‹è½½çš„æ–‡ä»¶å¼€å§‹å®‰è£…
```
# ç¯å¢ƒé”™è¯¯å¤„ç†
```shell
# æ‰§è¡Œä»£ç é”™è¯¯ error: linker `link.exe` not found
rustup toolchain install stable-x86_64-pc-windows-gnu
rustup default stable-x86_64-pc-windows-gnu
```
# åŸºç¡€å‘½ä»¤
```shell
# æŸ¥çœ‹ç‰ˆæœ¬
rustc --version
# å®‰è£…rustæ—¶ä¼šå®‰è£…Cargoï¼Œä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æ£€æŸ¥ç‰ˆæœ¬
cargo --version
# æœ¬åœ°æŸ¥çœ‹æ–‡æ¡£ï¼ˆæµè§ˆå™¨ï¼‰
rustup doc
# ç¼–è¯‘ä»£ç ç”ŸæˆäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶
rustc main.rs
rustc -o ç¼–è¯‘ååç§° ç¼–è¯‘å‰åç§°.rs
# ç¼–è¯‘ä»£ç ç”Ÿæˆåº“æ–‡ä»¶
rustc --crate-type lib ç¼–è¯‘å‰åç§°.rs
```
# cargoçš„ä½¿ç”¨
```shell
# åˆ›å»ºé¡¹ç›®
cargo new é¡¹ç›®åç§°
cargo new --lib é¡¹ç›®åç§°
# æ„å»ºé¡¹ç›®(é¡¹ç›®ç›®å½•ä¸‹)
cargo build --release
# æ£€æµ‹ä»£ç 
cargo check
# è¿è¡Œæµ‹è¯•
cargo run
cargo test
```
# é¡¹ç›®ç»“æ„
```shell
# åº“
project_name
|__Cargo.toml
|__src
   |__lib.rs
# å¸¸è§„é¡¹ç›®
project_name
|__Cargo.toml
|__src
   |main.rs
```
# Cargo.tomlæ–‡ä»¶
```toml
# é¡¹ç›®è®¾ç½®
[package]
# é¡¹ç›®åç§°
name = "rust-study"
# é¡¹ç›®ç‰ˆæœ¬
version = "0.1.0"
# ä½¿ç”¨çš„rustç‰ˆæœ¬
edition = "2021"
# ä½œè€…
authors = ["ak"]
# é¡¹ç›®ä¾èµ–é¡¹ï¼Œä»£ç çš„åŒ…æˆ–è€…åº“å«åšcrate
[dependencies]
# åœ¨æ­¤å¤„å¼•å…¥ä½¿ç”¨çš„åº“
rand = "0.3.23"
# åªåœ¨å¼€å‘ä¸­ä½¿ç”¨åˆ°çš„åº“
[dev-dependencies]
# åœ¨æ­¤å¤„å¼•å…¥ä½¿ç”¨çš„åº“
rand = "0.3.23"
# åªåœ¨æ­£å¼ç¯å¢ƒä¸­ç”Ÿæ•ˆçš„åº“-ä¸€èˆ¬ä¸ä½¿ç”¨
[build-dependencies]
# åœ¨æ­¤å¤„å¼•å…¥ä½¿ç”¨çš„åº“
```
# å˜é‡
```text
1ï¼šåœ¨rustä¸­ï¼Œä½¿ç”¨letå…³é”®å­—æ¥å£°æ˜å˜é‡
2ï¼šrustæ”¯æŒç±»å‹æ¨å¯¼ï¼Œå¯ä»¥æ˜¾ç¤ºæŒ‡å®šå˜é‡ç±»å‹
    let x: i32 = 5;
    let x = 5;
3ï¼šå˜é‡åè›‡å½¢å‘½åæ³•ï¼ˆSnake Caseï¼‰ï¼Œè€Œæšä¸¾å’Œç»“æ„å‘½åä½¿ç”¨å¸•æ–¯å¡å‘½åæ³•ï¼ˆPascal Caseï¼‰ï¼Œå¦‚æœå˜é‡æ²¡æœ‰ç”¨åˆ°å¯ä»¥å‰ç½®ä¸‹åˆ’çº¿ï¼Œæ¶ˆé™¤è­¦å‘Š
4ï¼šå¼ºåˆ¶ç±»å‹è½¬æ¢ Casting aValue to a Different Type
    let a = 3.1;
    let b = a as i32;
5ï¼šæ‰“å°å˜é‡ï¼ˆ{}ä¸{:?}ï¼‰
    println!("val: {}",x);
    println!("val: {x}");
6ï¼šrustçš„å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œå¦‚æœè¦å®šä¹‰å¯å˜ç±»å‹
    let mut a = 10;
7ï¼šrustå¯ä»¥éšè—å˜é‡
    let a = 5;
    let a = "abc";
```
# å¸¸é‡
```text
1ï¼šå¸¸é‡çš„å€¼å¿…é¡»æ˜¯åœ¨ç¼–è¯‘æ—¶å·²çŸ¥çš„å¸¸é‡è¡¨è¾¾å¼ï¼Œå¿…é¡»æŒ‡å®šç±»å‹å’Œå€¼
    const SECOND_HOUR: usize = 3600;
2ï¼šä¸Cè¯­è¨€çš„å®å®šä¹‰ä¸åŒï¼Œrustçš„constå¸¸é‡çš„å€¼è¢«ç›´æ¥åµŒå…¥åˆ°ç”Ÿæˆçš„åº•å±‚æœºå™¨ä»£ç ä¸­ï¼Œè€Œä¸æ˜¯è¿›è¡Œç®€å•çš„å­—ç¬¦æ›¿æ¢
3ï¼šå¸¸é‡åä¸é™æ€å˜é‡åå…¨éƒ¨å¤§å†™ï¼Œå•è¯ä¹‹é—´ä¸‹åˆ’çº¿åˆ†éš”
4ï¼šå¸¸é‡çš„ä½œç”¨åŸŸæ˜¯å—çº§ä½œç”¨åŸŸï¼Œä»–ä»¬åªåœ¨å£°æ˜ä»–ä»¬çš„ä½œç”¨åŸŸå†…å¯è§
```
# é™æ€å˜é‡
```text
1ï¼šä¸constå¸¸é‡ä¸åŒï¼Œstaticå˜é‡æ˜¯åœ¨è¿è¡Œæ—¶åˆ†é…å†…å­˜çš„
2ï¼šæ—¶å¯å˜çš„ï¼Œå¯ä»¥ä½¿ç”¨unsafeä¿®æ”¹
    unsafe {
        // ä¸å®‰å…¨çš„ä»£ç 
    }
3ï¼šé™æ€å˜é‡çš„ç”Ÿå‘½å‘¨æœŸä¸ºæ•´ä¸ªç¨‹åºçš„è¿è¡Œæ—¶é—´
    static MY_STATIC: I32 = 42;
```

# æ•°æ®ç±»å‹
## æ•´æ•°ç±»å‹
```text
æ— ç¬¦å·æ•´æ•°ç±»å‹ï¼šuå¼€å¤´ï¼Œæ•°å­—ä»£è¡¨å çš„ç©ºé—´
æœ‰ç¬¦å·æ•´æ•°ç±»å‹ï¼šiå¼€å¤´ï¼Œæ•°å­—ä»£è¡¨å çš„ç©ºé—´
length  |  Signed  |  Unsigned
8-bit       i8          u8
16-bit      i16         u16
32-bit      i32         u32
64-bit      i64         u64
128-bit     i128        u128
arch        isize       usize     ç”±ç¨‹åºè¿è¡Œçš„è®¡ç®—æœºå†³å®šï¼Œå¦‚æœæ˜¯64ä½è®¡ç®—æœºåˆ™æ˜¯64ä½ï¼Œ32ä½è®¡ç®—æœºåˆ™æ˜¯32ä½
i32::MAX è¿™ä¸¤ä¸ªæ–¹æ³•å¯ä»¥æŸ¥çœ‹å¤§å°æ”¯æŒ
i32::MIN
```
## æ•´æ•°å­—é¢å€¼
```text
Number literals  |  Example  |  ä¸­æ–‡
Decimal             98_222       åè¿›åˆ¶
Hex                 0xff         åå…­è¿›åˆ¶
Octal               0o77         å…«è¿›åˆ¶
Binary              0b1111_0000  äºŒè¿›åˆ¶
Byte(u8 only)       b'A'         byteç±»å‹
```
## æµ®ç‚¹æ•°
```text
f32ï¼š32ä½ï¼Œå•ç²¾åº¦
f64ï¼š64ä½ï¼ŒåŒç²¾åº¦
```
## å¸ƒå°”å€¼
```text
true :1ä½
falseï¼š1ä½
```
## å­—ç¬¦ç±»å‹
```text
// 4:å­—ç¬¦ç±»å‹
charï¼š4å­—èŠ‚ï¼Œå•ä¸ªå­—ç¬¦ï¼Œä½¿ç”¨å•å¼•å·
let x: char = 'z';
let y = 'ğŸ˜Š';
```
## å…ƒç»„å’Œæ•°ç»„
```text
å…ƒç»„å’Œæ•°ç»„çš„ç›¸åŒç‚¹ï¼š
    1ï¼šå…ƒç»„å’Œæ•°ç»„éƒ½æ˜¯Compound typesï¼Œè€ŒVecå’ŒMapéƒ½æ˜¯Collection types
    2ï¼šå…ƒç»„å’Œæ•°ç»„é•¿åº¦éƒ½æ˜¯å›ºå®šçš„
```
### å…ƒç»„
```text
tuples å¯å­˜å‚¨ä¸åŒç±»å‹çš„æ•°æ®ç±»å‹
fn main() {
    // åˆ›å»ºå…ƒç»„
    let t1: (char, i32, i32) = ('a', 2, 3);
    // è·å–å…ƒç´ 
    println!("{}", t1.1);
}
```
### æ•°ç»„
```rust
// åªèƒ½å­˜å‚¨ç»Ÿä¸€çš„æ•°æ®ç±»å‹
fn main() {
    let arr1: [char; 3] = ['a', 'b', 'c'];
    // åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œå†…å®¹æ˜¯10ä¸ª3
    let arr2 = [3; 10];
    // è·å–å…ƒç´ 
    arr1[1];
    // è·å–é•¿åº¦
    arr1.len();
    for item in arr1 {
        println!("{}", item)
    }
}
```
# ownership(æ‰€æœ‰æƒ)
```rust
fn main() {
    let arr = [1, 2, 3];
    let tup = (1, '2', 'a');
    // copy
    let arr_ownership = arr;
    let tup_ownership = tup;
    println!("arr {:?}", arr);
    println!("tup {:?}", tup);
    println!("arr_ownership {:?}", arr_ownership);
    println!("tup_ownership {:?}", tup_ownership);
    /*
        copyï¼šæ‹·è´
        moveï¼šç§»åŠ¨
            string
     */
    let str1 = String::from("abc");
    let str2 = str1;
    // æ­¤æ—¶ä¼šæŠ¥é”™ï¼Œå› ä¸ºstr1ä¸å­˜åœ¨äº†
    println!("str1: {}", str1);
}
```
## æ•°æ®æ‹·è´ä¸ç§»åŠ¨
### copy
```rust
fn main(){
    let c1 = 1;
    // æ­¤æ—¶æ‰§è¡Œäº†æ‹·è´
    let c2 = c1;
}
```
### move
```rust
fn main(){
    let s1 = String::from("hello");
    // æ­¤å¤„æ‰§è¡Œäº†æ‰€æœ‰æƒè½¬ç§»
    let s2 = s1;
    // åœ¨æ­¤å¤„å¼€å§‹s1å·²ç»ä¸å­˜åœ¨äº†
    // æ­¤å¤„åœ¨æ‰§è¡Œäº†æ·±æ‹·è´ï¼Œs2ä¾ç„¶å­˜åœ¨
    let s3 = s2.clone();
}
// =========================================================
fn main() {
    let s1: String = String::from("str1");
    // æ­¤å¤„ä¹Ÿè¿›è¡Œäº†æ‰€æœ‰æƒçš„è½¬ç§»ï¼Œåœ¨å‡½æ•°æ‰§è¡Œç»“æŸås1ä¹Ÿè¢«é”€æ¯äº†
    get_len(s1);
    // println!("{}",s1)
}

fn get_len(s: String) ->usize {
    return s.len();
}
```
## Stringå’Œ&str
```text
Stringæ˜¯ä¸€ä¸ªå †åˆ†é…çš„å¯å˜å­—ç¬¦ä¸²ç±»å‹
pub struct String {
    vec: Vec<u8>,
}

&stræ˜¯æŒ‡å­—ç¬¦ä¸²åˆ‡ç‰‡å¼•ç”¨ï¼Œæ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„
    ä¸å¯å˜å¼•ç”¨ï¼ŒæŒ‡å‘å­˜å‚¨åœ¨å…¶ä»–åœ°æ–¹çš„UTF-8ç¼–ç çš„å­—ç¬¦ä¸²æ•°æ®
    ç”±æŒ‡é’ˆå’Œé•¿åº¦æ„æˆ
    
Stringæ˜¯å…·æœ‰æ‰€æœ‰æƒçš„ï¼Œè€Œ&strå¹¶æ²¡æœ‰æ‰€æœ‰æƒ
Structä¸­å±æ€§ä½¿ç”¨String
    å¦‚æœä¸é€‚ç”¨æ˜¾ç¤ºå£°æ˜ç”Ÿå‘½å‘¨æœŸæ— æ³•ä½¿ç”¨&str
    ä¸åªæ˜¯éº»çƒ¦ï¼Œè¿˜æœ‰å¾ˆå¤šéšæ‚£
å‡½æ•°å‚æ•°æ¨èä½¿ç”¨&strï¼ˆå¦‚æœä¸æƒ³äº¤å‡ºæ‰€æœ‰æƒï¼‰
    &strä¸ºå‚æ•°ï¼Œå¯ä»¥ä¼ é€’&strå’ŒString
    &Stringä¸ºå‚æ•°ï¼Œåªèƒ½ä¼ &Stringï¼Œä¸èƒ½ä¼ &str
```
### &strè½¬String
```text
fn main() {
    let s1: String = String::from("str1");
    let s2 = "ä½ å¥½".to_owned();
    let s3 = "ä½ å¥½".to_string();
}
```


# åŒ¹é…æ¨¡å¼ match
```text
1: matchå…³é”®å­—å®ç°
2ï¼šå¿…é¡»è¦†ç›–æ‰€æœ‰çš„å˜ä½“
3ï¼šå¯ä»¥ç”¨_ã€..=ã€ä¸‰å…ƒ(if)ç­‰æ¥è¿›è¡ŒåŒ¹é…
```

```rust
fn main() {
    let  number = 0;
    match number {
        0=> println!("Zero"),
        1|2 => println!("One or Two"),
        3..=9 => println!("From Three to Nine"),
        n if n % 2 == 0 => println!("Even number"),
        _=> println!("Other")
    }
}
// =========================================================
enum Color {
    Red,
    Blue,
    Null,
}

impl Color {
    fn print_color(&self) {
        match self {
            Color::Red => { println!("my_red") }
            Color::Blue => { print!("my_blue"); }
            Color::Null => { print!("is null"); }
        }
    }
}

fn main() {
    let a: Color = Color::Red;
    a.print_color()
}

```
# ç»“æ„ä½“


## Ownershipä¸ç»“æ„ä½“
```text
1: æ‰€æœ‰å€¼åœ¨rustä¸­éƒ½åº”è¯¥æœ‰ä¸€ä¸ªowner
2ï¼šåœ¨åŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
3ï¼šå€¼åœ¨è¶…å‡ºä½œç”¨åŸŸæ—¶ä¼šè‡ªåŠ¨é”€æ¯
æ¯å½“å°†å€¼ä»ä¸€ä¸ªä½ç½®ä¼ é€’åˆ°å¦å¤–ä¸€ä¸ªä½ç½®æ—¶ï¼Œborrow checkeréƒ½ä¼šé‡æ–°è¯„ä¼°æ‰€æœ‰æƒ
    1ï¼šimmutable Borrow ä½¿ç”¨ä¸å¯å˜çš„å€Ÿç”¨ï¼Œå€¼çš„æ‰€æœ‰ä»å½’å‘é€æ–¹æ‰€æœ‰ï¼Œæ¥æ”¶æ–¹ç›´æ¥æ¥æ”¶å¯¹è¯¥å€¼çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯è¯¥å€¼çš„å‰¯æœ¬ã€‚ä½†æ˜¯ï¼Œä»–ä»¬ä¸èƒ½ä½¿ç”¨è¯¥å¼•ç”¨æ¥ä¿®æ”¹å®ƒæŒ‡å‘çš„å€¼ï¼Œç¼–è¯‘å™¨ä¸å…è®¸è¿™æ ·åšã€‚é‡Šæ”¾èµ„æºçš„è´£ä»»ä»ç”±å‘é€æ–¹æ‰¿æ‹…ã€‚ä»…å½“å‘é€è€…æœ¬èº«è¶…å‡ºèŒƒå›´æ—¶ï¼Œæ‰ä¼šåˆ é™¤å€¼
    2ï¼šmutable Borrow ä½¿ç”¨å¯å˜çš„å€Ÿç”¨æ‰€æœ‰æƒï¼Œåˆ é™¤å€¼çš„è´£ä»»ä¹Ÿæœ‰å‘é€è€…æ‰¿æ‹…ã€‚ä½†æ˜¯æ¥æ”¶æ–¹èƒ½å¤Ÿé€šè¿‡ä»–ä»¬æ¥æ”¶çš„å¼•ç”¨æ¥ä¿®æ”¹å€¼ã€‚
    3ï¼šMove è¿™æ˜¯æ‰€æœ‰æƒè½¬ç§»ï¼Œæ‰€æœ‰æƒä»ä¸€ä¸ªåœ°ç‚¹è½¬ç§»åˆ°å¦å¤–ä¸€ä¸ªåœ°ç‚¹ã€‚borrow checkerå…³äºé‡Šæ”¾è¯¥å€¼çš„å†³å®šå°†ç”±è¯¥å€¼çš„æ¥æ”¶æ–¹é€šçŸ¥ã€‚ç”±äºæ‰€æœ‰æƒå·²ç»é€å‘é€æ–¹è½¬ç§»åˆ°æ¥æ”¶æ–¹ï¼Œå› æ­¤å‘é€æ–¹åœ¨å°†å¼•ç”¨ç§»åŠ¨åˆ°å¦ä¸€ä¸ªä¸Šä¸‹æ–‡åä¸èƒ½å†ä½¿ç”¨è¯¥å¼•ç”¨ï¼Œå‘é€æ–¹å†ç§»åŠ¨åå¯¹valueçš„ä»»ä½•ä½¿ç”¨éƒ½ä¼šå¯¼è‡´é”™è¯¯
    
ç»“æ„ä½“çš„å…³è”å‡½æ•°çš„å‚æ•°ï¼š
    &self: (self: &Self) // ä¸å¯å˜å¼•ç”¨
    &mut self: (self: &mut Self) // å¯å˜å¼•ç”¨
    selfï¼š(self: Self) // Move
```
## å †å’Œæ ˆ copyå’Œmove
```text
stack:
    1: æ ˆå°†æŒ‰ç…§è·å–å€¼çš„é¡ºåºå¾å­˜å‚¨å€¼ï¼Œå¹¶ä»¥ç›¸åçš„é¡ºåºåˆ é™¤å€¼
    2ï¼šæ“ä½œé«˜æ•ˆï¼Œå‡½æ•°ä½œç”¨åŸŸå°±æ˜¯å†æ ˆä¸Š
    3ï¼šæ ˆä¸Šå­˜å‚¨çš„æ‰€æœ‰æ•°æ®éƒ½å¿…é¡»å…·æœ‰å·²çŸ¥å›ºå®šå¤§å°æ•°æ®
stackä¸Šçš„æ•°æ®ç±»å‹ï¼š
    1ï¼šåŸºç¡€æ•°æ®ç±»å‹
    2ï¼štupleå’Œarray
    3ï¼šstructä¸æšä¸¾ç­‰ä¹Ÿæ˜¯å­˜å‚¨åœ¨æ ˆä¸Šï¼Œå¦‚æœå±æ€§æœ‰Stringç­‰åœ¨å †ä¸Šçš„æ•°æ®ç±»å‹ä¼šæœ‰æŒ‡å‘å †çš„æƒ…å†µ
heapï¼š
    1ï¼šå †çš„è§„å¾‹æ€§æ¯”è¾ƒå·®ï¼Œå½“æŠŠä¸€äº›ä¸œè¥¿æ”¾åˆ°è¯·æ±‚çš„å †ä¸Šæ—¶ï¼Œè¯·æ±‚ç©ºé—´å¹¶è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼Œè¿™æ˜¯è¯¥ä½ç½®çš„åœ°å€
    2ï¼šé•¿åº¦ä¸ç¡®å®š
heapä¸Šçš„æ•°æ®ç±»å‹ï¼š
    Boxã€Rcã€Stringã€Vecç­‰
ä¸€èˆ¬æ¥è¯´åœ¨æ ˆä¸Šçš„æ•°æ®ç±»å‹éƒ½æ˜¯é»˜è®¤copyä½†æ˜¯structç­‰é»˜è®¤ä¸ºmoveï¼Œéœ€è¦copyåªéœ€è¦è®¾ç½®æ•°æ®ç±»å‹å®ç°Copyç‰¹è´¨å³å¯ï¼Œæˆ–æ˜¯è°ƒç”¨Cloneå‡½æ•°ï¼ˆéœ€è¦å®ç°Cloneç‰¹è´¨ï¼‰
```
## BoxæŒ‡é’ˆ
```text
Boxæ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒæä¾›å¯¹å †åˆ†é…å†…å­˜çš„æ‰€æœ‰æƒã€‚å®ƒå…è®¸ä½ å°†æ•°æ®å­˜å‚¨åˆ°å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šï¼Œå¹¶ä¸”åœ¨å¤åˆ¶æˆ–ç§»åŠ¨æ—¶ä¿æŒå †æ•°æ®çš„å”¯ä¸€æ‹¥æœ‰æƒã€‚
    ä½¿ç”¨Boxå¯ä»¥é¿å…ä¸€äº›å†…å­˜ç®¡ç†çš„é—®é¢˜ï¼Œå¦‚æ‚¬å‚æŒ‡é’ˆå’Œé‡å¤é‡Šæ”¾
    1ï¼šæ‰€æœ‰æƒè½¬ç§»
    2ï¼šé‡Šæ”¾å†…å­˜
    3ï¼šè§£å¼•ç”¨
    4ï¼šæ„å»ºé€’å½’æ•°æ®ç»“æ„
```

## copyä¸clone
```text
Moveï¼šæ‰€æœ‰æƒè½¬ç§»
Cloneï¼šæ·±æ‹·è´
Copyï¼šCopyæ˜¯åœ¨Cloneçš„åŸºç¡€å»ºç«‹çš„marker trait(Rustä¸­æœ€ç±»ä¼¼ç»§æ‰¿çš„å…³ç³»)
1ï¼štraitï¼šï¼ˆç‰¹è´¨ï¼‰æ˜¯ä¸€ç§å®šä¹‰å…±äº«è¡Œä¸ºçš„æœºåˆ¶ã€‚Cloneä¹Ÿæ˜¯ç‰¹è´¨
2ï¼šmarker trait æ˜¯ä¸€ä¸ªæ²¡æœ‰ä»»ä½•æ–¹æ³•çš„ traitï¼Œå®ƒä¸»è¦ç”¨äºå‘ç¼–è¯‘å™¨ä¼ é€’æŸäº›ä¿¡æ¯ï¼Œä»¥æ”¹å˜ç±»å‹çš„é»˜è®¤è¡Œä¸º
```
## Box
```rust
struct Point {
    x: f64,
    y: f64,
}

fn main() {
    // ä½¿ç”¨boxæŠŠæ•°æ®æ”¾åˆ°å †ä¸Š
    let p1 = Box::new(Point { x: 10.0, y: 20.0 });
    print!("x:{} y:{}", p1.x, p1.y);
}
```
# æµç¨‹æ§åˆ¶
## ifè¯­å¥
```rust
fn main() {
    let a = 10;
    if a == 10 {
        println!("ç­‰äº10");
    }else if a == 20{
        println!("ç­‰äº20");
    } else {
        println!("ç­‰äºå…¶ä»–");
    }
}
```
## if let
```rust
fn main() {
    let a: u8 = 3;
    if let 3 = a {
        print!("a is value 3");
    } else {
        print!("a is not 3");
    };
}
```
## match
```rust
fn main() {
    let number = 1;
    match number {
        1 => println!("1"),
        2 => println!("2"),
        3 => println!("3"),
        4 => println!("4"),
        _ => println!("number")
    }
}
```

## loop æ— é™å¾ªç¯
```rust
fn main() {
    let mut counter: i32 = 0;
    loop {
        counter += 1;
        // è·³å‡ºå¾ªç¯
        if counter == 10 {
            break;
        };
        println!("{counter}")
    }
}
```
## while æ¡ä»¶å¾ªç¯
```rust
fn main() {
    let mut counter: i32 = 0;
    while counter <= 10 {
        counter += 1;
        // è·³è¿‡å¾ªç¯
        if counter == 5 {
            continue;
        };
        // è·³å‡ºå¾ªç¯
        if counter == 10 {
            break;
        };
        println!("{counter}")
    }
}
```
## for æ¡ä»¶å¾ªç¯
```rust
fn main() {
    let a: [i32; 5] = [10, 20, 30, 40, 50];
    for i in a {
        println!("{i}")
    }

    for i in a.iter() {
        println!("{i}")
    }

    // å®Œæˆå€’è®¡æ—¶
    for i in (1..4).rev() {
        println!("{i}")
    };
}
```

# æ‰€æœ‰æƒ
```text
æ‰€æœ‰æƒæ˜¯rustæœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼Œè®©rustæ— éœ€GCå°±å¯ä»¥ä¿è¯å†…å­˜å®‰å…¨ã€‚
Rustçš„æ ¸å¿ƒç‰¹æ€§å°±æ˜¯æ‰€æœ‰æƒ
æ‰€æœ‰ç¨‹åºåœ¨è¿è¡Œæ—¶éƒ½å¿…é¡»ç®¡ç†å®ƒä»¬ï¼Œä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼
    1ï¼šæœ‰äº›è¯­è¨€æœ‰åƒåœ¾æ”¶é›†æœºåˆ¶ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ï¼Œä»–ä»¬ä¼šä¸æ–­çš„å¯»æ‰¾ä¸åœ¨ä½¿ç”¨çš„å†…å­˜è¿›è¡Œé‡Šæ”¾
    2ï¼šæœ‰äº›è¯­è¨€æ²¡æœ‰è‡ªåŠ¨åƒåœ¾å›æ”¶æœºåˆ¶ï¼Œéœ€è¦ç¨‹åºå‘˜æ˜¾å¼çš„åˆ†é…å’Œé‡Šæ”¾å†…å­˜
    3ï¼šrusté€šè¿‡æ‰€æœ‰æƒæœºåˆ¶æ¥ç®¡ç†å†…å­˜ï¼Œå…¶ä¸­åŒ…å«ä¸€ç»„ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶çš„æ£€æŸ¥çš„è§„åˆ™
```
```text
Stack(æ ˆ)ï¼šæŒ‰ç…§æ¥å—å€¼çš„é¡ºåºæ¥å­˜å‚¨ï¼ŒæŒ‰ç…§ç›¸åé¡ºåºæ¥å‡ºæ ˆï¼Œå…ˆè¿›åå‡ºã€‚
    å­˜å‚¨åœ¨æ ˆä¸Šçš„æ•°æ®å¿…é¡»æ‹¥æœ‰å·²çŸ¥å¤§å°ã€‚
heap(å †)ï¼šå†…å­˜ç»„ç»‡æ€§ç›¸æ¯”äºæ ˆç¨å·®ä¸€äº›ï¼Œå½“æŠŠæ•°æ®æ”¾å…¥å †å†…å­˜æ—¶ä¼šè¯·æ±‚ä¸€å®šé‡çš„ç©ºé—´ã€‚
    æ“ä½œç³»ç»Ÿåœ¨heapé‡Œæ‰¾ä¸€å—è¶³å¤Ÿå¤§å°çš„ç©ºé—´ï¼ŒæŠŠå®ƒæ ‡è®°ä¸ºåœ¨ç”¨ï¼Œå¹¶ä¸”è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡é’ˆæŒ‡å‘å†…å­˜å¤´åœ°å€ã€‚
    è¿™ä¸ªè¿‡ç¨‹å«åšå †å†…å­˜åˆ†é…ï¼Œä¹Ÿå«â€åˆ†é…â€œ
```
```text
æ‰€æœ‰æƒè§„åˆ™ï¼š
    æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„æ‰€æœ‰è€…
    æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
    å½“æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸæ—¶ï¼Œè¯¥å€¼ä¼šè¢«åˆ é™¤
```
## Stringç±»å‹
```text
Stringæ¯”åŸºç¡€æ ‡é‡ç±»å‹æ›´å¤æ‚
å­—ç¬¦ä¸²å­—é¢å€¼ï¼šç¨‹åºé‡Œæ‰‹å†™çš„å“ªäº›å­—ç¬¦ä¸²å€¼ï¼Œä»–ä»¬æ˜¯ä¸å¯å˜çš„
rustè¿˜æœ‰ç¬¬äºŒç§å­—ç¬¦ä¸²ç±»å‹ï¼šString
    åœ¨heapä¸Šåˆ†é…ï¼Œèƒ½å¤Ÿå­˜å‚¨åœ¨ç¼–è¯‘æ—¶ä½ç½®å¤§å°çš„æ–‡æœ¬
```
```rust
fn main() {
    // åˆ›å»ºString
    let mut s1: String = String::from("Hello");
    // è¿½åŠ å€¼
    s1.push_str(",World");
    print!("{s1}");
}
```
# å‡½æ•°
```rust
fn main() {
   // å®šä¹‰å­—ç¬¦ä¸²ç±»å‹
    let s1 = String::from("Test move");
    // è¿™é‡Œæ‰§è¡Œäº†moveæ“ä½œï¼Œæ‰€æœ‰è¿™è¡Œä»£ç ås1å˜å¾—ä¸åœ¨å¯ç”¨
    take_ownership(s1);
    // å®šä¹‰åŸºç¡€å˜é‡ç±»å‹
    let a1: i32 = 10;
    // åŸºç¡€ç±»å‹å®ç°äº†copyï¼Œæ‰€ä»¥è¿™è¡Œä»£ç åa1å˜é‡ç»§ç»­å¯ç”¨
    makes_copy(a1);

}

fn take_ownership(str1: String){
    println!("{str1}")
}

fn makes_copy(a1: i32){
    print!("{a1}");
}
```
```rust
fn main() {
    // å®šä¹‰å­—ç¬¦ä¸²ç±»å‹
    let mut  s1 = String::from("Test move");
    // è¿™é‡Œå‘ç”Ÿäº†å¼•ç”¨ã€å€Ÿç”¨ï¼Œs1ä¸ä¼šä¸¢å¤±å¯¹å€¼çš„æ‰€æœ‰æƒ
    let slen: usize = take_ownership(&mut s1);
    println!("{s1}çš„é•¿åº¦{slen}")
}

/**
  *&ç¬¦å·ä»£è¡¨æ¥æ”¶ä¸€ä¸ªå¼•ç”¨ï¼Œä¹Ÿå«å€Ÿç”¨ï¼Œè°ƒç”¨è€…ä¸ä¼šä¸¢å¤±å †ä¼ å…¥å‚æ•°çš„æ‰€æœ‰æƒ,
  * å€Ÿç”¨æ—¶é»˜è®¤ä¸å…è®¸ä¿®æ”¹æ•°æ®
  * å¢åŠ mutå…³é”®å­—æ—¶å˜ä¸ºå¯å˜ (str1: &mut String)
  */
fn take_ownership(str1: &mut String) -> usize {
    str1.push_str("haha");
    return str1.len();
}
```
## å­—ç¬¦ä¸²åˆ‡ç‰‡ &str
```rust
fn main() {
    let str1 = String::from("aa bb");
    let len_str = first_world(&str1);
    println!("{len_str}");
    // å­—ç¬¦ä¸²åˆ‡ç‰‡
    let a = &str1[0..2];
    let b = &str1[3..5];
    println!("{str1}");
    println!("{a}");
    println!("{b}");
}

fn first_world(s: &str) -> &str {
    // å­—ç¬¦ä¸²è½¬æ•°ç»„
    let str_arr: &[u8] = s.as_bytes();
    for (i, &item) in str_arr.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }
    return &s[..];
}
```
# ç»“æ„ä½“
## å®šä¹‰struct
```rust
struct User {
    name: String,
    age: u32,
    active: bool,
}
```
## å®ä¾‹åŒ–struct
```rust

```


## ä½¿ç”¨ç»“æ„ä½“
```rust
struct User {
    name: String,
    age: u32,
    active: bool,
}

fn main() {
    let user1 = User {
        name: String::from("ak"),
        age: 27,
        active: true,
    };
    // æ›´æ–°è¯­æ³•
    let user2 = User {
        name: String::from("ak1"),
        ..user1
    };
    // ä½¿ç”¨å­—æ®µ
    println!("{}", user1.name)
}
```
## å…ƒç»„ç»“æ„ä½“
```rust
fn main() {
    // å®šä¹‰å…ƒç»„struct
    struct Color(i32, i32, i32);
    let color1 = Color(255, 255, 255);
}
```
## ç»“æ„ä½“å®šä¹‰å’Œå±æ€§
```text
ç»“æ„ä½“æ˜¯ä¸€ç§ç”¨æˆ·å®šä¹‰çš„æ•°æ®ç±»å‹ï¼Œç”¨äºåˆ›å»ºè‡ªå®šä¹‰çš„æ•°æ®ç»“æ„
å®šä¹‰ï¼š
    struct Point{
        x: i32,
        y: i32,
    }
æ¯æ¡æ•°æ®çš„(xå’Œy)ç§°ä¸ºå±æ€§ã€å­—æ®µ(field)
é€šè¿‡ç‚¹(å¯¹è±¡.xx)æ¥è®¿é—®ç»“æ„ä½“ä¸­çš„å±æ€§
```
## ç»“æ„ä½“çš„æ–¹æ³•
```text
ç»“æ„ä½“çš„æ–¹æ³•æ˜¯æŒ‡ï¼Œé€šè¿‡å®ä¾‹è°ƒç”¨(&selfã€&mut selfã€self)
impl Point{
    fn æ–¹æ³•å(&self,other: &Point) -> f64 {
        // æ–¹æ³•ä½“
        return è¿”å›å€¼;
    }
}
```
## ç»“æ„ä½“å…³è”å‡½æ•°
```text
å…³è”å‡½æ•°æ˜¯ä¸ç±»å‹ç›¸å…³è”çš„å‡½æ•°ï¼Œè°ƒç”¨æ—¶ä¸ºç»“æ„ä½“åç§°::å‡½æ•°å()
impl Point {
    fn new(x: u32,y: u32) -> Self {
        return Point {x,y}
    }
}
```
## å…³è”å˜é‡
```text
å…³è”å˜é‡æ˜¯æŒ‡ï¼Œå’Œç»“æ„ä½“ç±»å‹ç›¸å…³è”çš„å˜é‡ï¼Œä¹Ÿå¯ä»¥åœ¨ç‰¹è´¨æˆ–æ˜¯æšä¸¾ä¸­
impl Point {
    const PI: f64 = 3.14159
}
è°ƒç”¨ï¼šPoint::PI
```

# æšä¸¾
```text
æšä¸¾(enums) æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹ï¼Œç”¨äºè¡¨ç¤ºå…·æœ‰ä¸€ç»„ç¦»æ•£å¯èƒ½å€¼çš„å˜é‡
    æ¯ç§å¯èƒ½å€¼éƒ½ç§°ä¸ºâ€œvariantâ€ï¼ˆå˜ä½“ï¼‰
    æšä¸¾å::å˜ä½“å
æšä¸¾çš„å¥½å¤„
    å¯ä»¥ä½¿ä»£ç æ›´åŠ ä¸¥è°¨ã€æ›´æ˜“è¯»
    More robust programs
```
```rust
// åˆ›å»ºæšä¸¾
enum Shpe {
    Circle(f64,f32),
    Rectangle(f64),
    Square(f32),
}
```
## å¸¸ç”¨æšä¸¾
```rust
pub enum Option<T> {
    None,
    Some(T),
}
pub enum Result<T,E> {
    Ok(T),
    Err(E),
}
```
# rustä»£ç ç»„ç»‡
```text
ä»£ç ç»„ç»‡ï¼š
    å“ªäº›ç»†èŠ‚å¯ä»¥æš´æ¼ï¼Œå“ªäº›ç»†èŠ‚éœ€è¦ç§æœ‰
    å“ªäº›ä½œç”¨åŸŸå†…æœ‰æ•ˆ
æ¨¡å—ç³»ç»Ÿï¼š
    package(åŒ…): cargoçš„ç‰¹æ€§ï¼Œè®©æ„å»ºã€æµ‹è¯•ã€å…±äº«crate
    crate(å•å…ƒåŒ…)ï¼šä¸€ä¸ªæ¨¡å—æ ‘ï¼Œå®ƒå¯ä»¥äº§ç”Ÿä¸€ä¸ªlibraryæˆ–å¯æ‰§è¡Œæ–‡ä»¶
    module(æ¨¡å—)ï¼šuseã€è®©ç¨‹åºå‘˜æ§åˆ¶ä»£ç çš„ç»„ç»‡ã€ä½œç”¨åŸŸã€ç§æœ‰è·¯å¾„ã€‚
    path(è·¯åŠ²)ï¼šä¸ºstructã€functionã€moduleç­‰å‘½åçš„æ–¹å¼
```
## packageå’Œcrate
```text
crateçš„ç±»å‹ï¼š
    binary
    library
crate root:
    æ˜¯æºä»£ç æ–‡ä»¶
    rustç¼–è¯‘å™¨ä»è¿™é‡Œå¼€å§‹ï¼Œç»„æˆä½ çš„crateæ ¹module
ä¸€ä¸ªpackageï¼š
    åŒ…å«ä¸€ä¸ªCargo.toml,å®ƒæè¿°äº†æ€ä¹ˆæ¥æ„å»ºè¿™äº›Crates
    åªèƒ½åŒ…å«0~1ä¸ªlibrary Crate
    å¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„binary Crate
    å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªcrate (library æˆ– binary)
```
## module
### å®šä¹‰æ¨¡å—
```rust
pub mod A {
    pub mod B {
        pub mod C {
            pub fn cfn() {
                println!("cfn")
            }
        }
    }
}

fn main() {
    // ç»å¯¹è·¯å¾„è°ƒç”¨
    crate::A::B::C::cfn();
    // ç›¸å¯¹è·¯å¾„
    A::B::C::cfn();
}
```
## useå…³é”®å­—
```rust
pub mod A {
    pub mod B {
        pub mod C {
            pub fn cfn() {
                println!("cfn")
            }
        }
    }
}

use A::B::C as C;
// å¯¹äºå¤–éƒ¨æš´éœ²
// pub use A::B::C as C;
fn main() {
    // ä½¿ç”¨useå¼•ç”¨è°ƒç”¨
    C::cfn();
}
```
## æ‰¹é‡å¼•å…¥
```rust
use std::{
    io,
    cmp::Ordering,
};
use std::clone::*;
fn main() {}
```
# å¸¸ç”¨é›†åˆ
## Vector
```text
Vec<T>,å«åšvector
    æ˜¯ç”±æ ‡å‡†åº“æä¾›çš„
    å¯ä»¥å­˜å‚¨å¤šä¸ªå€¼
    åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„å€¼
    å€¼åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾
```
```rust
fn main() {
    // åˆ›å»ºVec
    let v1: Vec<i32> = Vec::new();
    // ä½¿ç”¨å®åˆ›å»º
    let mut v2: Vec<i32> = vec![1, 2, 3];
    // æ·»åŠ å…ƒç´ 
    v2.push(10);
    // è¯»å–
    let vl1 = &v2[1];
    let vl2 = v2.get(2);
    println!("{}", {vl1});
}
```
## String

## HashMap


